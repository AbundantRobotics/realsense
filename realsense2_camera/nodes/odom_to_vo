#!/usr/bin/env python
from __future__ import print_function
import rospy
import tf2_ros
import argparse
from nav_msgs.msg import Odometry
from quaternion import AxisAngle, Quat
import numpy as np
from numpy import linalg as ln
from geometry_msgs.msg import TransformStamped

pub = None

def publish_transformed(msg, T, br):
    global pub
    out = Odometry()
    out.header = msg.header
    out.header.frame_id = 'odom'
    out.child_frame_id = 'base_footprint_link'

    base_rot = Quat(
        T.transform.rotation.x,
        T.transform.rotation.y,
        T.transform.rotation.z,
        T.transform.rotation.w
    )
    base_pos = np.array([
        T.transform.translation.x,
        T.transform.translation.y,
        T.transform.translation.z
    ])

    base_trans = np.block([
        [base_rot.to_matrix(), base_pos.reshape(3, 1)],
        [np.zeros((1, 3))    , 1                     ]
    ])

    msg_pos = np.array([
        msg.pose.pose.position.x,
        msg.pose.pose.position.y,
        msg.pose.pose.position.z
    ])
    msg_orient = Quat(
        msg.pose.pose.orientation.x,
        msg.pose.pose.orientation.y,
        msg.pose.pose.orientation.z,
        msg.pose.pose.orientation.w
    )
    msg_pose = np.block([
        [msg_orient.to_matrix(), msg_pos.reshape(3, 1)],
        [np.zeros((1,3)), 1]
    ])

    nodom = base_trans * msg_pose

    out.pose.pose.position.x = nodom[0,3]
    out.pose.pose.position.y = nodom[1,3]
    out.pose.pose.position.z = nodom[2,3]

    # orientation
    out_rot = Quat.from_matrix(nodom[:3,:3])
    out.pose.pose.orientation = out_rot.msg

    # covariance
    cov = np.asmatrix(np.array(msg.pose.covariance)).reshape((6,6))
    cov[:3,:3] = base_trans[:3,:3] * cov[:3,:3] * base_trans[:3,:3].T
    cov[3:9,3:9] = base_trans[:3,:3] * cov[3:9,3:9] * base_trans[:3,:3].T
    # print(cov)
    out.pose.covariance = np.asarray(cov).flatten()

    # angular vel
    ang = np.asmatrix(np.array([
        msg.twist.twist.angular.x,
        msg.twist.twist.angular.y,
        msg.twist.twist.angular.z
    ])).T
    out_ang = base_trans[:3,:3] * ang
    out.twist.twist.angular.x = out_ang[0]
    out.twist.twist.angular.y = out_ang[1]
    out.twist.twist.angular.z = out_ang[2]

    # linear accel
    accel = np.asmatrix(np.array([
        msg.twist.twist.linear.x,
        msg.twist.twist.linear.y,
        msg.twist.twist.linear.z
    ])).T
    out_accel = base_trans[:3,:3] * accel
    out.twist.twist.linear.x = out_accel[0]
    out.twist.twist.linear.y = out_accel[1]
    out.twist.twist.linear.z = out_accel[2]

    out.twist.covariance = out.pose.covariance

    if pub:
        try:
            pub.publish(out)
        except Exception as e:
            if rospy.is_shutdown():
                return
            print(e)


def main():
    parser = argparse.ArgumentParser('transform Odom Message')
    parser.add_argument('topic')
    parser.add_argument('target_frame')
    parser.add_argument('src_frame')
    args, unknown = parser.parse_known_args()
    rospy.init_node('transform_odom')


    buf = tf2_ros.Buffer()
    lis = tf2_ros.TransformListener(buf)
    br = tf2_ros.TransformBroadcaster()
    trans = None
    while not trans:
        try:
            trans = buf.lookup_transform(args.target_frame, args.src_frame, rospy.Time())
        except Exception as e:
            pass
    global pub
    pub = rospy.Publisher('odometry_transformed', Odometry, queue_size=10)
    sub = rospy.Subscriber(args.topic, Odometry, lambda m: publish_transformed(m, trans, br), queue_size=10)
    rospy.spin()
    return 0


if __name__ == '__main__':
    import sys
    sys.exit(main())
